Mew is a library targetting R5RS/R7RS scheme, which provides some
conveniences inspired from Goo, Clojure and Arc to allow writing more
compact code.

== Re-Exports

Mew re-exports
SRFI-1 (List library),
SRFI-69 (Basic hash tables),
SRFI-158 (Generators and Accumulators),
{{(chicken io)}},
{{(chicken irregex)}},
{{(chicken pretty-print)}}},
and {{matchable}}.


== Definitions, bindings and assignments

<syntax>(def <variable> <expression>)</syntax>
<syntax>(def (<variable> <formals>) <expression>)</syntax>

Alias for {{define}}.

<syntax>(fun <formals> <body>...)</syntax>

Alias for {{lambda}}.

<syntax>(fun* <pattern> <body>...)</syntax>

Lambda which pattern matches all its arguments (ala the {{match}} macro).

<syntax>(loc (<pat1> <val1> ... <patN> <valN>) <body>)</syntax>

Binds local variables in pattern (ala the {{match}} macro)
{{pat1}} to the result of evaluating {{val1}},
then {{pat2}} to {{val2}}, etc., then evaluates {{body}}.

Assignments can refer to previously assigned values of the {{loc}}.

<syntax>(rec <name> <expression>)</syntax>
<syntax>(rec (<name> <formals>) <expression>)</syntax>

See Module%20(chicken%20base)#rec or SRFI-31.

Often, using {{def}} in an inner scope is preferable to using {{rec}}.

<syntax>(set <location> <expression>)</syntax>

Like {{set!}}, but also return the value of {{<expression>}}.


== Control flow

<syntax>(esc <escape> <body>)</syntax>

Bind {{<escape>}} to the current continuation, then run {{<body>}}.
Code should not pass {{<escape>}} outside the lexical scope
and only call it once---use {{call/cc}} else.

<syntax>(fin <body> . <cleanup>)</syntax>

Evaluate {{<body>}}, then evaluate {{<cleanup>}}, even if {{<body>}}
used a non-local exit (as from {{esc}}).

Returns value of {{<body>}}, so can also be used as a replacment
for Common Lisp PROG1.

<syntax>(rep <name> ((<var> <init>) ...) <body>)</syntax>

Explicit form of named let.

<syntax>(seq . <body>)</syntax>

Alias for {{begin}}.

<syntax>(unless <cond> <expr>...)</syntax>
<syntax>(when <cond> <expr>...)</syntax>

As in R7RS-small.

<syntax>(while <cond> <expr>...)</syntax>
<syntax>(until <cond> <expr>...)</syntax>

Evaluate {{<expr>}} while {{<cond>}} is true/false.


== Numeric helpers

<procedure>(inc <num>)</procedure>
<procedure>(dec <num>)</procedure>

Increment or decrement the argument by 1.

<procedure>(div . <num>)</procedure>

Alias for {{floor-quotient}}.

<procedure>(mod . <num>)</procedure>

Alias for {{floor-remainder}}.


== General helpers

<procedure>(app <proc> . <args>)</procedure>

Alias for {{apply}}.

<syntax>(op <form>)</syntax>

Returns a procedure that evaluates {{<form>}} with {{_}} bound to its
only argument.

If {{<form>>} is empty, behaves as {{values}}, i.e. the identity function.

{{(op 5)}} is the function that always returns 5.

{{(op + 2 _)}} is the function that adds 2 to its argument.

<syntax>(op* <form>)</syntax>

Returns a procedure that evaluates {{<form>}} with {{...}} expanded
to all its arguments.  {{...}} must only appear once and must not
be nested further.  If {{...} does not appear in {{<form>}}, it's
added implicitly at the end.

{{(op* + 5)}} is the function that adds 5 and then all its arguments.

{{(op* - 0 ... 2)}} is the function that subtracts all its arguments from 0
and finally 2.

<procedure>(negate <fun>)</procedure>

Alias for {{complement}}.

<procedure>(comp <fun>...)</procedure>

Alias for {{compose}}.

<procedure>(per <fun>...)</procedure>

Reverse function composition.

<procedure>(str . <args>)</procedure>

Returns a new string composed by concatenating the strings given by
applying {{display}} to all {{<args>}}.

<syntax>(one-of <val>...)</syntax>

Expands to a lambda expression that is true if its argument is
{{equal?}} to any of the {{<val>}} passed.


== I/O helpers

<procedure>(prn . <args>)</procedure>

{{write}} all {{args}} separated by spaces and terminated by a newline
to the current output stream.

<procedure>(puts . <args>)</procedure>

{{display}} all {{args}} terminated by a newline to the current output stream.

<procedure>(eof)</procedure>

Return an object for which {{eof-object?}} is true.

<procedure>(slurp <obj>)</procedure>

If {{<obj>}} is an input-port, read all data into a string.
If {{<obj>}} is a string, read all data from the file named {{<<obj>>}.
If {{<obj>}} is false, read all data from {{*current-input-port*}}.


== Equality

<procedure>(=? <val>...)</procedure>

Alias for {{equal?}}.

<procedure>(<>? <val1> <val2> ...)</procedure>

Return true if all values are pairwise different.


== Data types

<procedure>(get <obj> <idx>)</procedure>
<procedure>(at <obj> <idx>)</procedure>
<procedure>(set (at <obj> <idx>) <val>)</procedure>

Generalized accessor, supports indexing into lists, vectors,
hash-tables, strings.

<procedure>(tbl <key1> <val1> ... <keyN> <valN>)</procedure>

Construct a hash-table; using {{equal?}}.

<procedure>(keys <hash-table>)</procedure>

Alias for {{hash-table-keys}}.

<procedure>(vals <hash-table>)</procedure>

Alias for {{hash-table-values}}.

<procedure>(empty? <obj>)</procedure>

Test if {{<obj>}} is an empty list/string/vector/hash-table.

<procedure>(len <obj>)</procedure>

Return the length of the list/vector/string/hash-table/generator {{<obj>}}.

<syntax>(for (<var> <obj>) <body>...)</syntax>
<syntax>(for ((<key> . <val>) <tbl>) <body>...)</syntax>

If {{<obj>}} is a list or a vector, iterate over its elements.
If {{<obj>}} is a procedure, consider it a SRFI-158 generator
and iterate over its values.
If {{<obj>}} is a hash-table, iterate over its keys and values.


== Generators and Accumulators

<procedure>(gen <val>)</procedure>

Generic generator for list/vector/string/hash-table/generator.

<procedure>(cycle <val>...)</procedure>

Alias for {{circular-generator}}.

<procedure>(range <val>...)</procedure>

Alias for {{make-range-generator}}.

<procedure>(giterate <fun> <val>)</procedure>

Generator returning {{<val>}}, {{(<fun> <val>)}}, {{(<fun> (<fun (<val>)))}}...

<procedure>(gwindow <gen> <len>)</procedure>

Generator yielding a sliding window of length {{<len>}} (as a list)
over the values yielded by the generator {{<gen>}}.  Yields never if
the generator yielded fewer than {{<len>}} elements.

<procedure>(gslice-when <pred> <gen>)</procedure>

Partition the elements yielded by the generator {{<gen>}} into lists:
starts a new list when the predicate {{<pred>}} called with the
previous and the current element of the generator returns true.

<procedure>(genumerate <gen>)</procedure>

Takes the values yielded by the generator {{<gen>}} and yields them as
a {{cons}} where the first cell is an index incremented on every
yield.

<procedure>(gfix <gen>)</procedure>

Returns a generator that runs the generator {{<gen>}} until it yields
a value {{equal?}} to the preceding one, then stops.

<procedure>(final <gen>)</procedure>

Run the generator {{<gen>}} until it stops and return its final value.

<procedure>(into <acc> <gen>...)</procedure>

Feed all elements of the generators {{<gen>}} into the accumulator {{<acc>}}.
Uses {{gen}} to convert {{<gen>}} into a generator.
If {{<acc>}} is a list/vector/hash-table/string, accumulate into
a corresponding accumulator initialized to {{<acc>}}.

<syntax>(accumulate (<var> <acc>) body ...)</syntax>

Bind {{<var>}} to the accumulator {{<var>}} and run {{body}}.
Finally, return the result of accumulation.
If {{<acc>}} is a list/vector/hash-table/string, accumulate into
a corresponding accumulator initialized to {{<acc>}}.

<procedure>(tally-accumulator)</procedure>

Returns an accumulator that counts how often each element was
accumulated.  The accumulator results in a hash-table of objects to
numbers.

<procedure>(group-by-accumulator <f>)</procedure>

Returns an accumulator that stores all elements in lists in a hash-table,
applying {{<f>}} to the element to compute the key.

<procedure>(inject <f> [<init>])</procedure>

Returns a procedure that takes an generator (or something convertible
by {{gen}}) and folds the function {{<f>}} over its values.  If given,
folding starts with {{<init>}}, else with the first element yielded by
the generator.  If the generator is empty, return {{(<f>)}}.

== Regular expressions

<procedure>(?~ <str> <irx>)</procedure>

Matches the string {{<str>}} against the irregex (string or sexp) {{<irx>}}
without anchoring.  Returns false on no match, else a list of all
match data strings.

<procedure>(gmatch <irx> <str>)</procedure>

Returns a generator that for each match of the irregex {{<irx>}} in
the string {{<str>}} either yields the match, or a list of all
match data strings (if there are any).

<procedure>(gsplit <irx> <str> <max>?)</procedure>

Returns a generator that yields the strings between matches of the
irregex {{<irx>}} in the string {{<str>}}, at most {{<max>>} times
(by default, unlimited).

When the pattern {{<irx>}} uses match data, the result is unspecified.


== Special syntax

<syntax>(-> a -> b c -> d e f)</syntax>
<syntax>(->> a ->> b c ->> d e f)</syntax>

Nesting macros: {{->}} inserts the previous part as the second argument:
{{(-> a -> b c -> d e f)}} expands to {{(d (b a c) e f)}}.

{{->>}} inserts the previous part as the last argument:
{{(->> a ->> b c ->> d e f)}} expands to {{(d e f (b c a))}}.

You can mix {{->}} and {{->>}} macros:
{{(->> a -> b c ->> d e f)}} expands to {{(d e f (b a c))}}.

<syntax>(fun-> b c -> d e f)</syntax>
<syntax>(fun->> b c ->> d e f)</syntax>

Nesting lambdas: like {{->}} but the nesting starts with the argument
of the lambda.
{{(fun-> b c -> d e f)}} expands to {{(lambda (x) (-> x -> b c -> d e f))}}.
{{(fun->> b c ->> d e f)}} expands to {{(lambda (x) (->> x ->> b c ->> d e f))}}.

<syntax>(set-> loc -> ...)</syntax>
<syntax>(set->> loc ->> ...)</syntax>

Mutation with nesting macros: shortcut for {{(set loc (-> loc ...))}}.

<syntax>(given <val> <cond> <then> <else>?)<syntax>

Evaluate {{<val>}}.  Then, when {{<cond>}} is not false, behaves like
{{(-> <val> -> <then>}}, otherwise like {{(-> <val> -> <else>)}}
(or just {{<val>}} if no {{<else>}} was passed).
