Mew is a library targetting R5RS/R7RS scheme, which provides some
conveniences inspired from Goo, Clojure and Arc to allow writing more
compact code.

== Re-Exports

Mew re-exports
SRFI-1 (List library),
SRFI-69 (Basic hash tables),
SRFI-158 (Generators and Accumulators),
and {{matchable}}.

== Definitions, bindings and assignments

<syntax>(def <variable> <expression>)</syntax>
<syntax>(def (<variable> <formals>) <expression>)</syntax>

Alias for {{define}}.

<syntax>(fun <formals> <body>)</syntax>

Alias for {{lambda}}.

<syntax>(loc (<pat1> <val1> ... <patN> <valN>) <body>)</syntax>

Binds local variables in pattern (ala the {{match}} macro)
{{pat1}} to the result of evaluating {{val1}},
then {{pat2}} to {{val2}}, etc., then evaluates {{body}}.

Assignments can refer to previously assigned values of the {{loc}}.

<syntax>(rec <name> <expression>)</syntax>
<syntax>(rec (<name> <formals>) <expression>)</syntax>

See Module%20(chicken%20base)#rec or SRFI-31.

Often, using {{def}} in an inner scope is preferable to using {{rec}}.

<syntax>(set <variable> <expression>)</syntax>

Alias for {{set!}}.


== Control flow

<syntax>(esc <escape> <body>)</syntax>

Bind {{<escape>}} to the current continuation, then run {{<body>}}.
Code should not pass {{<escape>}} outside the lexical scope
and only call it once---use {{call/cc}} else.

<syntax>(fin <body> . <cleanup>)</syntax>

Evaluate {{<body>}}, then evaluate {{<cleanup>}}, even if {{<body>}}
used a non-local exit (as from {{esc}}).

Returns value of {{<body>}}, so can also be used as a replacment
for Common Lisp PROG1.

<syntax>(rep <name> ((<var> <init>) ...) <body>)</syntax>

Explicit form of named let.

<syntax>(seq . <body>)</syntax>

Alias for {{begin}}.

<syntax>(unless <cond> <expr>...)</syntax>
<syntax>(when <cond> <expr>...)</syntax>

As in R7RS-small.

<syntax>(while <cond> <expr>...)</syntax>
<syntax>(until <cond> <expr>...)</syntax>

Evaluate {{<expr>}} while {{<cond>}} is true/false.


== Numeric helpers

<procedure>(inc <num>)<procedure>
<procedure>(dec <num>)<procedure>

Increment or decrement the argument by 1.

<procedure>(div . <num>)</procedure>

Alias for {{floor-quotient}}.

<procedure>(mod . <num>)</procedure>

Alias for {{floor-remainder}}.


== General helpers

<procedure>(app <proc> . <args>)</procedure>

Alias for {{apply}}.

<syntax>(op <form>)</syntax>

Returns a procedure that evaluates {{<form>}} with {{_}} bound to its
only argument.

If {{<form>>} is empty, behaves as {{(op _)}}, i.e. the identity function.

{{(op 5)}} is the function that always returns 5.

{{(op + 2 _)}} is the function that adds 2 to its argument.

<procedure>(str . <args>)</procedure>

Returns a new string composed by concatenating the strings given by
applying {{display}} to all {{<args>}}.


== I/O helpers

<procedure>(prn . <args>)<procedure>

{{write}} all {{args}} separated by spaces and terminated by a newline
to the current output stream.

<procedure>(puts . <args>)<procedure>

{{display}} all {{args}} terminated by a newline to the current output stream.

<procedure>(eof)<procedure>

Return an object for which {{eof-object?}} is true.


== Data types

<procedure>(get <obj> <idx>)</procedure>
<procedure>(at <obj> <idx>)</procedure>
<procedure>(set (at <obj> <idx>) <val>)</procedure>

Generalized accessor, supports indexing into lists, vectors,
hash-tables, strings.

<procedure>(tbl <key1> <val1> ... <keyN> <valN>)</procedure>

Construct a hash-table; using {{equal?}}.

<procedure>(keys <hash-table>)</procedure>

Alias for {{hash-table-keys}}.

<procedure>(vals <hash-table>)</procedure>

Alias for {{hash-table-values}}.

<procedure>(keyvals <hash-table>)</procedure>

Return a list of alternating keys and values of the hash table.

<procedure>(empty? <obj>)</procedure>

Test if {{<obj>}} is an empty list/string/vector/hash-table.

<procedure>(len <obj>)</procedure>

Return the length of the list/vector/string/hash-table/generator {{<obj>}}.

<syntax>(for (<var> <obj>) <body>...)</syntax>
<syntax>(for ((<key> <val>) <tbl>) <body>...)</syntax>

If {{<obj>}} is a list or a vector, iterate over its elements.
If {{<obj>}} is a procedure, consider it a SRFI-158 generator
and iterate over its values.
If {{<obj>}} is a hash-table, iterate over its keys and values.


== Generators

<procedure>(cycle <val>...)</procedure>

Alias for {{circular-generator}}.

<procedure>(range <val>...)</procedure>

Alias for {{make-range-generator}}.

<procedure>(giterate <fun> <val>)<procedure>

Generator returning {{<val>}}, {{(<fun> <val>)}}, {{(<fun> (<fun (<val>)))}}...

<procedure>(gfix <gen>)</procedure>

Returns a generator that runs the generator {{<gen>}} until it yields
a value {{equal?}} to the preceding one, then stops.

<procedure>(final <gen>)</procedure>

Run the generator {{<gen>}} until it stops and return its final value.


== Special syntax

<syntax>(-> a -> b c -> d e f)</syntax>
<syntax>(->> a ->> b c ->> d e f)</syntax>

Nesting macros: {{->}} inserts the previous part as the second argument:
{{(-> a -> b c -> d e f)}} expands to {{(d (b a c) e f)}}.

{{->>}} inserts the previous part as the last argument:
{{(->> a ->> b c ->> d e f)}} expands to {{(d e f (b c a))}}.

You can mix {{->}} and {{->>}} macros:
{{(->> a -> b c ->> d e f)}} expands to {{(d e f (b a c))}}.
